# HMMM program to recursively compute fibonacci numbers

# Program conventions:
# * r15 always holds the base of the currently executing stack frame
# * main stack frame at 0xFF with baseptr and retptr = 0
# * when a function is called, r1 will hold the returnptr value
# * when a function returns, r1 will hold the return value

############################################
# Init things before starting main
setn r15 127
addn r15 127
storer r0 r15 # set main's retptr
addn r15 1
storer r0 r15 # set main's baseptr
jumpn :main:  # start executing main

############################################
# fib(n)
# Stack Frame structure - 6 bytes
# a       = -5
# b       = -4
# c       = -3
# n       = -2
# retptr  = -1
# baseptr = -0
:fib:
# Finish the stack frame init
## store the returnptr for the caller
copy r14 r15
addn r14 -1
storer r1 r14

## LOGIC STUBBED - Skip the function body for now ##

# Return to the caller
## load the returnptr
copy r14 r15
addn r14 -1
loadr r13 r14
## Move to the caller's stackframe
loadr r15 r15
## actually return to caller
jumpr r13

############################################
# main
# Stack Frame structure - 3 bytes
# z       = -2
# retptr  = -1
# baseptr = -0
:main:
# call fib(n) :: init fib's frame then jump
## set baseptr in new frame
copy r14 r15
addn r14 -3
storer r15 r14
## set n in new frame
setn r1 5
addn r14 -2
storer r1 r14
## Change which frame is currently executing and jump to the function
addn r15 -3
calln r1 :fib:

# store the return value in z -- r1 will hold the return value by convention
copy r14 r15
addn r14 -2
storer r1 r14

# Declare victory
halt
